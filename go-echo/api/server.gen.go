// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Resp defines model for Resp.
type Resp struct {
	Value *string `json:"value,omitempty"`
}

// Status The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty"`
}

// AppGetParams defines parameters for AppGet.
type AppGetParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// AppSetParams defines parameters for AppSet.
type AppSetParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /) (POST /)
	AppDefault(ctx echo.Context) error

	// (GET /v1/get)
	AppGet(ctx echo.Context, params AppGetParams) error

	// (POST /v1/set)
	AppSet(ctx echo.Context, params AppSetParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AppDefault converts echo context to params.
func (w *ServerInterfaceWrapper) AppDefault(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppDefault(ctx)
	return err
}

// AppGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AppGetParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppGet(ctx, params)
	return err
}

// AppSet converts echo context to params.
func (w *ServerInterfaceWrapper) AppSet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AppSetParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppSet(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/*", wrapper.AppDefault)
	router.POST(baseURL+"/*", wrapper.AppDefault)
	router.GET(baseURL+"/v1/get", wrapper.AppGet)
	router.POST(baseURL+"/v1/set", wrapper.AppSet)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+yVzW7jNhDHX2XA9tAFVCm7e/OpRjYIgh5qJLkUgYGlyJE0W4qjkqMEruF3L0jJtR17",
	"2xx6aIG9xPQw8/WfH8dbZbgf2KOXqBZbFU2Hvc7HW+bW4SqwcD02S79JRm0tCbHXbhV4wCCEUS0kjFgo",
	"i9EEGtK1Wqhr9qLJR9AedKhJgg4biBhIO/oDLfQYo24RtGPfwgtJBxp+ks2AIJ0WmMLVGEE6hGznJp/P",
	"g5SqUMNRQVuVA6XDaVWPbwo1+aoogXyrdru/LFx/QSNqV6h7jEMKf5r1WbsxZ31DhAfRMsbLJX6eLj9P",
	"tVpsyGMEDY5bMtoBhsABerboJrEoQhxJdO0QGg5gqWkwoBcYArdB9z35FtA/U2Dfp2kXQN640Sb7/c3D",
	"IyxXd2lYFu5X1/lLCXc58BjRQr2Bp/Z+db3+oRMZ4qKqWpJurEvDfdWGwbwr4Uab7lD6fr5mD4J0AREG",
	"QoMx6W+16MXcimGLxb6tybHIxUwmi6LJxRJ+5RGM9tCQt8CjQM8BQdfpKB3FE2WSf8cvIAwvHH6bGCMB",
	"8nn2T8vVHXzCSK2H25EsHnozjkdbtvkF5A71QLGy+X+rnCK+O2cuNXF5njFrMnf50pHpIHY8Ogs1pgeC",
	"fuwhw5OEeZoTh8GU12xxfWZIuRsOvRa1UOTl44cDteQFWwwJsVm285qW4ChKyjWLHSeMjA5hk8V5pTs8",
	"dhgw0aDBcN+zh4jHATKpMbOXQRJO3KQ6SbDPJXwfsFEL9V11WDnVvG+q82VzeDI6BJ2/z6kutWPxGV2a",
	"xY+NNhn1U5Rea04ebnzrKHYlLP0m1XrZ9cjHsZlXRQIrpse1J+loPhP+5azc+m+uoCF0tgAOR6HrSX7j",
	"CL28aRclE/mG89ohceluOQxpDKpQzxjiJNJVeVW+TzLygF4PpBbqY3lVfkwYa+nyiKr0p0VJH0lNnQS+",
	"s1PET9jo0YkqVMA4sI8T9R+urib4vaDPnnoYHJnsW32JKfn+h+WfMMhbNXd0OuBffp5wngr4t7LNG/hC",
	"vrnVGYV9u5P6uo1q8ZQEUetdoQaO3+R6q1y7QlXP76uZsK+BdouSoQy6R8GQ/LeKUqLfRwwbVSiv+4R5",
	"/iiOyn/9WNbfxD8TP06qf5Xbh/+M+nO8mtmh9v8vrQ+W7V6vdLNb7/4MAAD//7bCtDNzCwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
